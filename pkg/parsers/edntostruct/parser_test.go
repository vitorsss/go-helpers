package edntostruct

import (
	"go/types"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/vitorsss/go-helpers/pkg/assertutil"
)

func Test_Parser_parseEDNToGolangStructs(t *testing.T) {
	type args struct {
		options     []Option
		packagePath string
		prefix      string
		ednContent  []byte
	}
	type want struct {
		result string
		err    error
	}

	tests := []struct {
		name string
		args *args
		want *want
	}{
		{
			name: "should parse simple namespaced edn",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "SimpleNamespaced",
				ednContent:  []byte(`{:namespace/id "13", :namespace/amount 23, :namespace/sub {:sub/id 1}}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

type SimpleNamespacedNamespace struct {
	Amount int64                        "json:\"amount\" edn:\"namespace/amount\""
	ID     string                       "json:\"id\" edn:\"namespace/id\""
	Sub    SimpleNamespacedNamespaceSub "json:\"sub\" edn:\"namespace/sub\""
}

type SimpleNamespacedNamespaceSub struct {
	ID int64 "json:\"id\" edn:\"sub/id\""
}
`,
			},
		},
		{
			name: "should parse default tag values edn",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "DefaultTags",
				ednContent:  []byte(`{:time #inst "2024-05-05T12:29:17Z" :uuid #uuid "4f25e20d-522d-4963-897f-eb04d6d133a2"}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

import (
	time "time"

	uuid "github.com/google/uuid"
)

type DefaultTags struct {
	Time time.Time "json:\"time\" edn:\"time\""
	Uuid uuid.UUID "json:\"uuid\" edn:\"uuid\""
}
`,
			},
		}, {
			name: "should parse keyword edn values as 'enums'",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "KeywordEnum",
				ednContent:  []byte(`{:namesss/enum1 :namesss.test/eee :namesss/enum2 :jjj}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

import (
	errors "errors"

	edn "olympos.io/encoding/edn"
)

type KeywordEnumNamesss struct {
	Enum1 KeywordEnumNamesssEnum1Code "json:\"enum_1\" edn:\"namesss/enum1\""
	Enum2 KeywordEnumNamesssEnum2Code "json:\"enum_2\" edn:\"namesss/enum2\""
}

type KeywordEnumNamesssEnum1Code string

const (
	KeywordEnumNamesssEnum1CodeEee = "eee"
)

func (e *KeywordEnumNamesssEnum1Code) UnmarshalEDN(data []byte) error {
	var keyword edn.Keyword
	err := edn.Unmarshal(data, &keyword)
	if err != nil {
		return err
	}
	raw, found := strings.CutPrefix(string(keyword), "namesss.test/")
	if !found {
		return errors.New("KeywordEnumNamesssEnum1Code.UnmarshalEDN: invalid keyword")
	}
	*e = KeywordEnumNamesssEnum1Code(raw)
	return err
}

func (e KeywordEnumNamesssEnum1Code) MarshalEDN() ([]byte, error) {
	return edn.Marshal(edn.Keyword(fmt.Sprintf("namesss.test/%s", e)))
}

type KeywordEnumNamesssEnum2Code string

const (
	KeywordEnumNamesssEnum2CodeJjj = "jjj"
)

func (e *KeywordEnumNamesssEnum2Code) UnmarshalEDN(data []byte) error {
	var keyword edn.Keyword
	err := edn.Unmarshal(data, &keyword)
	if err != nil {
		return err
	}
	*e = KeywordEnumNamesssEnum2Code(keyword)
	return err
}

func (e KeywordEnumNamesssEnum2Code) MarshalEDN() ([]byte, error) {
	return edn.Marshal(edn.Keyword(e))
}
`,
			},
		},
		{
			name: "should parse set edn types as 'entity.Set'",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "SetsSetsSets",
				ednContent:  []byte(`{:superset/ok #{{:subtype/id 2 :subtype/name "ttt"}}}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

import (
	entity "github.com/vitorsss/go-helpers/pkg/entity"
)

type SetsSetsSetsSuperset struct {
	Ok entity.Set[SetsSetsSetsSupersetSubtype] "json:\"ok\" edn:\"superset/ok\""
}

type SetsSetsSetsSupersetSubtype struct {
	ID   int64  "json:\"id\" edn:\"subtype/id\""
	Name string "json:\"name\" edn:\"subtype/name\""
}
`,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := NewParser(tt.args.options...)
			destPackage := types.NewPackage(tt.args.packagePath, tt.args.packagePath[strings.LastIndex(tt.args.packagePath, "/")+1:])
			result, err := p.ParseEDNToGolang(
				destPackage,
				tt.args.prefix,
				tt.args.ednContent,
			)

			if assertutil.Error(t, tt.want.err, err) {
				assert.Equal(t, tt.want.result, string(result))
			}
		})
	}
}
