package edntostruct

import (
	"go/types"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/vitorsss/go-helpers/pkg/assertutil"
)

func Test_SchemaParser_parseEDNToGolangStructs(t *testing.T) {
	type args struct {
		options     []Option
		packagePath string
		prefix      string
		ednSchema   []byte
	}
	type want struct {
		result string
		err    error
	}

	tests := []struct {
		name string
		args *args
		want *want
	}{
		{
			name: "should parse simple namespaced edn",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "SimpleNamespaced",
				ednSchema:   []byte(`{:namespace/valid? Bool, :namespace/amount java.math.BigDecimal, :namespace/cents Int, :namespace/id Str, :namespace/sub {:sub/id Int}}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

type SimpleNamespacedNamespace struct {
	Amount float64                      "json:\"amount\" edn:\"namespace/amount\""
	Cents  int64                        "json:\"cents\" edn:\"namespace/cents\""
	ID     string                       "json:\"id\" edn:\"namespace/id\""
	Sub    SimpleNamespacedNamespaceSub "json:\"sub\" edn:\"namespace/sub\""
	Valid  bool                         "json:\"valid?\" edn:\"namespace/valid?\""
}

type SimpleNamespacedNamespaceSub struct {
	ID int64 "json:\"id\" edn:\"sub/id\""
}
`,
			},
		},
		{
			name: "should parse simple enums",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "SimpleEnum",
				ednSchema:   []byte(`{:key (enum :a :b)}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

import (
	edn "olympos.io/encoding/edn"
)

type SimpleEnum struct {
	Key SimpleEnumKeyCode "json:\"key\" edn:\"key\""
}

type SimpleEnumKeyCode string

const (
	SimpleEnumKeyCodeA SimpleEnumKeyCode = "a"
	SimpleEnumKeyCodeB SimpleEnumKeyCode = "b"
)

func (e *SimpleEnumKeyCode) UnmarshalEDN(data []byte) error {
	var keyword edn.Keyword
	err := edn.Unmarshal(data, &keyword)
	if err != nil {
		return err
	}
	*e = SimpleEnumKeyCode(keyword)
	return err
}

func (e SimpleEnumKeyCode) MarshalEDN() ([]byte, error) {
	return edn.Marshal(edn.Keyword(e))
}
`,
			},
		},
		{
			name: "should parse constrained optional keys",
			args: &args{
				packagePath: "example.com/some/package/path",
				prefix:      "OptionalConstrained",
				ednSchema:   []byte(`{(optional-key :key) (constrained Str not-empty)}`),
			},
			want: &want{
				result: `// Code generated by endtostruct DO NOT EDIT
package path

type OptionalConstrained struct {
	Key *string "json:\"key\" edn:\"key\""
}
`,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := NewSchemaParser(tt.args.options...)
			destPackage := types.NewPackage(tt.args.packagePath, tt.args.packagePath[strings.LastIndex(tt.args.packagePath, "/")+1:])
			result, err := p.ParseSchemaSchemaToGolang(
				destPackage,
				tt.args.prefix,
				tt.args.ednSchema,
			)

			if assertutil.Error(t, tt.want.err, err) {
				assert.Equal(t, tt.want.result, string(result))
			}
		})
	}
}
