package edntostruct

import (
	"bytes"
	"fmt"
	"go/types"
	"regexp"
	"slices"
	"strings"

	"github.com/pkg/errors"
	"mvdan.cc/gofumpt/format"
)

var (
	packageNameIndexRegex = regexp.MustCompile("\\d+")
	typeNameEqualRegex    = regexp.MustCompile("(type\\s+\\w+)\\s+=")
)

func printPackage(
	destPackage *types.Package,
) ([]byte, error) {
	qualifier := func(other *types.Package) string {
		if destPackage == other {
			return ""
		}
		return other.Name()
	}
	buffer := bytes.NewBufferString("// Code generated by endtostruct DO NOT EDIT\n")
	buffer.WriteString(fmt.Sprintf("package %s", destPackage.Name()))
	buffer.WriteString("\n\nimport (\n")
	imports := destPackage.Imports()
	slices.SortStableFunc(imports, func(a, b *types.Package) int {
		return strings.Compare(a.Path(), b.Path())
	})
	for _, importParckage := range imports {
		buffer.WriteString(fmt.Sprintf(`%s "%s"`, importParckage.Name(), importParckage.Path()))
		buffer.WriteString("\n")
	}
	buffer.WriteString(")")
	scope := destPackage.Scope()
	names := scope.Names()
	slices.Sort(names)
	for _, name := range names {
		buffer.WriteString("\n\n")
		object := scope.Lookup(name)
		unformatted := types.ObjectString(object, qualifier)
		unformatted = typeNameEqualRegex.ReplaceAllString(unformatted, "$1")
		buffer.Write([]byte(unformatted))

		if extra, ok := object.Type().(TypeExtraStringer); ok {
			buffer.WriteString(extra.ExtraString())
		}
	}

	data, err := format.Source(
		buffer.Bytes(),
		format.Options{
			ModulePath: destPackage.Path(),
			ExtraRules: true,
		},
	)
	if err != nil {
		return nil, errors.Wrapf(err, "error while formatting: %s", string(buffer.Bytes()))
	}

	return data, nil
}
